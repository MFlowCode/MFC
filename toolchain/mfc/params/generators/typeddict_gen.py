"""
TypedDict Generator for MFC Case Files.

Generates a TypedDict that provides IDE auto-completion for Python case files.
Only includes parameters with valid Python identifiers (209 of 3247).
For indexed parameters like patch_icpp(1)%vel(1), use ./mfc.sh params.
"""

from typing import Dict, List, Tuple
from ..schema import ParamType
from ..registry import REGISTRY
from ..descriptions import get_description
from .. import definitions  # noqa: F401  pylint: disable=unused-import


def _param_type_to_python_type(param_type: ParamType) -> str:
    """Convert ParamType to Python type annotation string."""
    type_map = {
        ParamType.INT: "int",
        ParamType.REAL: "float",
        ParamType.LOG: "str",  # "T" or "F"
        ParamType.STR: "str",
        ParamType.ANALYTIC_INT: "Union[int, str]",
        ParamType.ANALYTIC_REAL: "Union[float, str]",
    }
    return type_map.get(param_type, "Any")


def get_valid_identifier_params() -> List[Tuple[str, ParamType, str]]:
    """Get parameters that are valid Python identifiers.

    Returns:
        List of (name, param_type, description) tuples
    """
    result = []
    for name, param in sorted(REGISTRY.all_params.items()):
        if name.isidentifier():
            desc = get_description(name) or ""
            result.append((name, param.param_type, desc))
    return result


def generate_typeddict_source() -> str:
    """Generate Python source code for MFCParams TypedDict.

    Returns:
        Python source code as string
    """
    params = get_valid_identifier_params()

    lines = [
        '"""',
        'MFC Case Parameter Types for IDE Auto-completion.',
        '',
        'This file is auto-generated by ./mfc.sh generate --json-schema',
        'Provides TypedDict for IDE auto-completion in Python case files.',
        '',
        'Usage:',
        '    from mfc.params.case_types import MFCParams',
        '',
        '    case: MFCParams = {',
        "        'm': 200,",
        "        'weno_order': 5,",
        '        # IDE provides auto-completion for keys!',
        '    }',
        '',
        f'Includes {len(params)} parameters with valid Python identifiers.',
        'For indexed parameters (patch_icpp, fluid_pp, etc.), use:',
        '    ./mfc.sh params <query>',
        '"""',
        '',
        'from typing import TypedDict, Union, Any',
        '',
        '',
        'class MFCParams(TypedDict, total=False):',
        '    """',
        '    MFC simulation case parameters.',
        '    ',
        '    All fields are optional (total=False).',
        '    Use ./mfc.sh params <name> for parameter documentation.',
        '    """',
    ]

    # Group by type for readability
    by_type: Dict[str, List[Tuple[str, str]]] = {}
    for name, ptype, desc in params:
        py_type = _param_type_to_python_type(ptype)
        if py_type not in by_type:
            by_type[py_type] = []
        by_type[py_type].append((name, desc))

    # Output grouped by type
    type_order = ["int", "float", "str", "Union[int, str]", "Union[float, str]", "Any"]
    for py_type in type_order:
        if py_type not in by_type:
            continue

        type_label = {
            "int": "Integer parameters",
            "float": "Real/float parameters",
            "str": "String/logical parameters",
            "Union[int, str]": "Analytic integer parameters (can be expressions)",
            "Union[float, str]": "Analytic real parameters (can be expressions)",
            "Any": "Other parameters",
        }.get(py_type, py_type)

        lines.append(f'    # --- {type_label} ---')

        for name, desc in sorted(by_type[py_type]):
            # Escape quotes in description
            desc_escaped = desc.replace('"', '\\"') if desc else ""
            if desc_escaped:
                lines.append(f'    {name}: {py_type}  # {desc_escaped}')
            else:
                lines.append(f'    {name}: {py_type}')

        lines.append('')

    return '\n'.join(lines)


def write_typeddict(output_path: str) -> int:
    """Write TypedDict to file.

    Args:
        output_path: Path to write the file

    Returns:
        Number of parameters included
    """
    content = generate_typeddict_source()
    with open(output_path, 'w') as f:
        f.write(content)
    return len(get_valid_identifier_params())
