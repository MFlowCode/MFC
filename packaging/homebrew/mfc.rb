# typed: strict
# frozen_string_literal: true

# Homebrew formula for MFC (Multiphase Flow Code)
# This formula is automatically deployed to the MFlowCode/homebrew-mfc tap by GitHub Actions workflow
class Mfc < Formula
  desc "Exascale multiphase/multiphysics compressible flow solver"
  homepage "https://mflowcode.github.io/"
  url "https://github.com/MFlowCode/MFC/archive/refs/tags/v5.1.5.tar.gz"
  sha256 "229ba4532d9b31e54e7db67cc6c6a4c069034bb143be7c57cba31c5a56fe6a0b"
  license "MIT"
  head "https://github.com/MFlowCode/MFC.git", branch: "master"

  depends_on "cmake" => :build
  depends_on "gcc" => :build

  depends_on "boost"
  depends_on "fftw"
  depends_on "hdf5"
  depends_on "open-mpi"
  depends_on "openblas"
  depends_on "python@3.12"

  # Skip cleanup for Python venv to preserve C extensions as-is
  # Python wheels manage their own RPATHs and don't need Homebrew's relocation
  skip_clean "libexec/venv"

  def install
    # Create Python virtual environment inside libexec (inside Cellar for proper bottling)
    venv = libexec/"venv"
    system Formula["python@3.12"].opt_bin/"python3.12", "-m", "venv", venv
    system venv/"bin/pip", "install", "--upgrade",
           "pip", "setuptools", "wheel",
           "setuptools-scm",
           "hatchling", "hatch-vcs",
           "editables"

    # Install Cantera from PyPI using pre-built wheel (complex package, doesn't need custom flags)
    # Cantera has CMake compatibility issues when building from source with newer CMake versions
    # Match the version constraint from toolchain/pyproject.toml
    system venv/"bin/pip", "install", "--only-binary=:all:", "cantera>=3.1.0"

    # Install MFC Python package and dependencies into venv
    # Use editable install (-e) to avoid RECORD file issues when venv is symlinked at runtime
    # Dependencies will use pre-built wheels from PyPI
    # Keep toolchain in buildpath for now - mfc.sh needs it there
    #
    # MFC's toolchain uses VCS-derived versioning (via Hatch/hatch-vcs) and Homebrew builds from
    # GitHub release tarballs without a .git directory. Use --no-build-isolation so the build
    # backend can see our environment variables, and set SETUPTOOLS_SCM_PRETEND_VERSION which
    # hatch-vcs respects when VCS metadata is unavailable.
    pretend_env = {
      "SETUPTOOLS_SCM_PRETEND_VERSION_FOR_MFC" => version.to_s,
      "SETUPTOOLS_SCM_PRETEND_VERSION_FOR_mfc" => version.to_s,
      "SETUPTOOLS_SCM_PRETEND_VERSION"         => version.to_s, # Fallback for hatch-vcs/setuptools-scm
    }
    saved_env = {}
    pretend_env.each do |k, v|
      saved_env[k] = ENV.fetch(k, nil)
      ENV[k] = v
    end

    begin
      system venv/"bin/pip", "install", "--no-build-isolation", "-e", buildpath/"toolchain"
    ensure
      pretend_env.each_key do |k|
        if saved_env[k].nil?
          ENV.delete(k)
        else
          ENV[k] = saved_env[k]
        end
      end
    end

    # Create symlink so mfc.sh uses our pre-installed venv
    mkdir_p "build"
    ln_sf venv, "build/venv"

    # Now build MFC with pre-configured venv
    # Set VIRTUAL_ENV so mfc.sh uses existing venv instead of creating new one
    ENV["VIRTUAL_ENV"] = venv

    # Also set pretend-version env vars for mfc.sh in case it tries to reinstall toolchain
    ENV["SETUPTOOLS_SCM_PRETEND_VERSION_FOR_MFC"] = version.to_s
    ENV["SETUPTOOLS_SCM_PRETEND_VERSION_FOR_mfc"] = version.to_s
    ENV["SETUPTOOLS_SCM_PRETEND_VERSION"] = version.to_s

    # Build MFC using pre-configured venv
    # Must run from buildpath (MFC root directory) where toolchain/ exists
    Dir.chdir(buildpath) do
      system "./mfc.sh", "build", "-t", "pre_process", "simulation", "post_process", "-j", ENV.make_jobs.to_s
    end

    # After build completes, install Python toolchain to prefix
    prefix.install "toolchain"

    # Install only executable files from hashed build dirs
    Dir.glob("build/install/*/bin/*").each do |p|
      next if !File.file?(p) || !File.executable?(p)

      bin.install p
      (bin/File.basename(p)).chmod 0755
    end

    # Install main mfc.sh script
    libexec.install "mfc.sh"

    # Install examples
    prefix.install "examples"

    # Create smart wrapper script in libexec; bin wrapper will be generated by Homebrew
    (libexec/"mfc").write <<~EOS
        #!/usr/bin/env bash
        set -euo pipefail

        # Unset VIRTUAL_ENV to ensure mfc.sh uses our configured venv
        unset VIRTUAL_ENV || true

        # Save original working directory
        ORIG_DIR="$(pwd)"

        # Process arguments and convert relative paths to absolute paths
        declare -a ARGS=()
        for arg in "$@"; do
          # If argument looks like a file path and exists as relative path
          if [[ "$arg" =~ \\.(py|txt|json|yaml|yml)$ ]] && [ -e "${ORIG_DIR}/${arg}" ]; then
            ARGS+=("${ORIG_DIR}/${arg}")
          else
            ARGS+=("$arg")
          fi
        done

        # Friendly help and guardrails
        if [[ ${#ARGS[@]} -eq 0 ]] || [[ "${ARGS[0]-}" == "--help" ]] || [[ "${ARGS[0]-}" == "-h" ]]; then
          cat <<'HHELP'
      MFC (Homebrew) #{version}

      Usage:
        mfc <case.py> [options]

      Examples:
        mfc case.py -n 2
        mfc examples/1D_sodshocktube/case.py -n 2 -t pre_process simulation

      Notes:
        - This Homebrew wrapper uses prebuilt binaries and a preinstalled venv.
        - Developer commands (build, clean, test, etc.) are not available here.
          Clone the MFC repo for the full developer workflow.
      HHELP
          exit 0
        fi

        # Handle --version flag
        if [[ "${ARGS[0]-}" == "--version" ]] || [[ "${ARGS[0]-}" == "-v" ]]; then
          echo "MFC (Homebrew) #{version}"
          exit 0
        fi

        # Find first non-flag argument
        first_nonflag=""
        for arg in "${ARGS[@]}"; do
          if [[ "$arg" != -* ]]; then
            first_nonflag="$arg"
            break
          fi
        done

        # Check if no case file provided
        if [[ -z "${first_nonflag}" ]]; then
          echo "mfc (Homebrew): missing case file."
          echo "Usage: mfc <case.py> [options]"
          echo "Example: mfc case.py -n 2"
          exit 2
        fi

        # Check if user accidentally used 'mfc run' syntax (even with flags before it)
        if [[ "${first_nonflag}" == "run" ]]; then
          echo "mfc (Homebrew): The 'run' command is not needed."
          echo "Usage: mfc <case.py> [options]"
          echo "Example: mfc case.py -n 2"
          exit 2
        fi

        # Require a readable Python file (not a directory)
        if [[ ! "${first_nonflag}" =~ .py$ ]] || [[ ! -f "${first_nonflag}" ]]; then
          echo "mfc (Homebrew): first argument must be a readable Python case file."
          echo "Given: ${first_nonflag}"
          echo "Usage: mfc <case.py> [options]"
          exit 2
        fi

        # Always prepend "run" since this wrapper only supports running cases
        ARGS=("run" "${ARGS[@]}")

        # Create a temporary working directory (Cellar is read-only)
        TMPDIR="$(mktemp -d)"
        trap 'rm -rf "${TMPDIR}"' EXIT
        cd "${TMPDIR}"

        # Copy only mfc.sh (small, fast)
        cp "#{libexec}/mfc.sh" .

        # Create a minimal CMakeLists.txt to prevent the cat error
        # mfc.sh reads this to get version info
        cat > CMakeLists.txt << 'CMAKE_EOF'
      cmake_minimum_required(VERSION 3.18)
      project(MFC VERSION #{version})
      CMAKE_EOF

        # Symlink toolchain (read-only is fine, no copy needed)
        ln -s "#{prefix}/toolchain" toolchain

        # Symlink examples (read-only is fine)
        ln -s "#{prefix}/examples" examples

        # Create build directory structure
        mkdir -p build

        # Symlink the persistent venv (no copy)
        ln -s "#{libexec}/venv" build/venv

        # Copy only pyproject.toml (tiny file, prevents reinstall checks)
        cp "#{prefix}/toolchain/pyproject.toml" build/pyproject.toml

        # Create a sitecustomize.py file that patches MFC paths before any imports
        # This runs automatically at Python startup and ensures paths are correct
        cat > sitecustomize.py << 'SITECUSTOMIZE_EOF'
      import sys
      import os

      # Add toolchain to path
      sys.path.insert(0, "#{prefix}/toolchain")

      # Patch MFC paths before mfc.common is imported anywhere
      _mfc_temp_root = os.getcwd()

      def _patch_mfc_common():
          """Patches mfc.common module to use temp directory for writable files."""
          import mfc.common
          mfc.common.MFC_ROOT_DIR = _mfc_temp_root
          mfc.common.MFC_BUILD_DIR = os.path.join(_mfc_temp_root, "build")
          mfc.common.MFC_LOCK_FILEPATH = os.path.join(mfc.common.MFC_BUILD_DIR, "lock.yaml")
          # Keep toolchain and examples pointing to Homebrew installation
          mfc.common.MFC_TOOLCHAIN_DIR = "#{prefix}/toolchain"
          mfc.common.MFC_EXAMPLE_DIRPATH = "#{prefix}/examples"

      def _patch_mfc_build():
          """Patches MFCTarget to use pre-installed binaries."""
          from mfc.build import MFCTarget

          # Override get_install_binpath to use pre-installed binaries
          _original_get_install_binpath = MFCTarget.get_install_binpath
          def _homebrew_get_install_binpath(self, case):
              return "#{bin}/" + self.name
          MFCTarget.get_install_binpath = _homebrew_get_install_binpath

          # Override is_buildable to skip building main targets
          _original_is_buildable = MFCTarget.is_buildable
          def _homebrew_is_buildable(self):
              if self.name in ["pre_process", "simulation", "post_process", "syscheck"]:
                  return False
              return _original_is_buildable(self)
          MFCTarget.is_buildable = _homebrew_is_buildable

      # Apply patches immediately
      _patch_mfc_common()
      _patch_mfc_build()
      SITECUSTOMIZE_EOF

        # Set PYTHONPATH to include current directory so sitecustomize.py is found
        export PYTHONPATH="${TMPDIR}:#{prefix}/toolchain:${PYTHONPATH:-}"

        # Always run with --no-build in Homebrew package
        exec ./mfc.sh "${ARGS[@]}" --no-build
    EOS
    (libexec/"mfc").chmod 0755

    # Create a thin exec wrapper in bin that calls the libexec script (audit-friendly)
    bin.write_exec_script libexec/"mfc"
  end

  def post_install
    # Fix executable permissions for libexec wrapper
    (libexec/"mfc").chmod 0755
  end

  # Override to skip relocation checks for Python C extensions in venv
  # Python wheels (especially orjson, cantera) have Mach-O headers without enough
  # padding for Homebrew's longer paths. This is safe because:
  # 1. The venv is self-contained in libexec and uses relative paths
  # 2. Python manages its own RPATH for C extensions
  # 3. The venv is never relocated after installation
  def skip_relocation?(file, _type)
    file.to_s.include?("/libexec/venv/")
  end

  def caveats
    <<~EOS
      MFC has been installed successfully!

      To run a case:
        mfc <case.py> [options]

      Pre-built binaries are also available directly:
        pre_process, simulation, post_process

      Examples are available in:
        #{prefix}/examples

      Quick start:
        cp #{prefix}/examples/1D_sodshocktube/case.py .
        mfc case.py -n 2

      Note: Cantera 3.1.0 is pre-installed in the MFC virtual environment.
    EOS
  end

  test do
    # Test that all binaries exist and are executable
    %w[pre_process simulation post_process].each do |prog|
      assert_path_exists bin/prog
      assert_predicate bin/prog, :executable?
    end

    # Test that toolchain is installed
    assert_path_exists prefix/"toolchain"

    # Test that venv exists and has required packages
    assert_path_exists libexec/"venv"
    assert_predicate (libexec/"venv/bin/python"), :executable?

    # Test that examples exist
    assert_path_exists prefix/"examples"

    # Test that mfc wrapper works
    system bin/"mfc", "--help"

    # Test running a complete 1D Sod shock tube case from a separate directory
    # This comprehensive test ensures the entire MFC workflow functions correctly
    # and that the wrapper script properly handles relative paths
    testpath_case = testpath/"test_run"
    testpath_case.mkpath

    # Copy case.py from examples to an independent test directory
    cp prefix/"examples/1D_sodshocktube/case.py", testpath_case/"case.py"

    # Run all three stages: pre_process, simulation, and post_process
    # This runs a full 1D Sod shock tube (1000 timesteps, 399 cells)
    cd testpath_case do
      system bin/"mfc", "case.py", "-n", "1"
    end

    # Verify silo_hdf5 output files were created by post_process
    assert_path_exists testpath_case/"silo_hdf5"
    assert_predicate testpath_case/"silo_hdf5", :directory?
  end
end
